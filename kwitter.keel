model Account {
    fields {
        username Text @unique
        identity Identity @unique
        following Follow[]
        tweets Tweet[]
    }

    actions {
        //
        // The two-step process of needing to create the identity first could lead to problems.
        create newAccount() with (username) {
            @set(account.identity = ctx.identity)
        }
        //
        // Retrieve the currently signed in account
        get getAccount() {
            @where(account.identity == ctx.identity)
        }
        //
        // Neat way of excluding your own records
        list findAccounts(username?) {
            @where(account.identity != ctx.identity)
        }
        //
        // BUG :(
        list findUnfollowedAccounts(username?) {
            @where(ctx.identity not in account.following.follower.identity)
        }
        read consistentFeed(id) returns (Any)
    }

    @permission(
        expression: ctx.isAuthenticated,
        actions: [get, list, create, update]
    )
}

model Follow {
    fields {
        follower Account @relation(following)
        followee Account
    }

    actions {
        //
        // This @set should be possible:
        //    @set(follow.follower.id = ctx.identity.account)
        // It would mean we don't need to provide follower.id as input
        // Requires: backlinks & @set to support database columns
        create follow() with (follower.id, followee.id)
    }

    // With a new follow, the feed must be populated 
    // with existing tweets
    @on(
        [create],
        backPopulate
    )

    // Neat way of preventing duplicate follows
    @unique([follower, followee])

    @permission(
        expression: ctx.isAuthenticated,
        actions: [get, list, create, update]
    )
}

model Feed {
    fields {
        account Account
        username Text
        content Text
        tweetedAt Timestamp
    }

    actions {
        // Neat use of relationships to filter to my feeds
        list feed() {
            @where(feed.account.identity == ctx.identity)
            @orderBy(tweetedAt: desc)
            @permission(expression: ctx.isAuthenticated)
        }
    }
}

model Tweet {
    fields {
        content Text
        account Account
    }

    actions {
        //
        // This @set should be possible:
        //    @set(tweet.account = ctx.identity.account)
        // It would mean we don't need to provide account.id as input
        // Requires: backlinks & @set to support data{base columns
        create newTweet() with (content, account.id)
        //
        // Neat use of @where and @order to get my top feed.
        // Paging is then done at time of request (however I often find myself wanting a @limit attribute)
        list myTweets() {
            @where(tweet.account.identity == ctx.identity)
            @orderBy(createdAt: desc)
        }
        delete deleteTweet(id)
    }

    // With a new tweet we need to propogate
    // it to all follower's feeds
    @on(
        [create],
        propogateTweet
    )

    @permission(
        expression: ctx.isAuthenticated,
        actions: [get, list, create, update]
    )
}

job Seed {
    @permission(expression: true)
}
